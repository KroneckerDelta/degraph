<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Degraph Manual</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The manual for Degraph, a tool for visulizing and testing package dependencies in JVM code.">
    <meta name="author" content="Jens Schauder">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">

    <link href="bootstrap/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../assets/js/html5shiv.js"></script>
    <![endif]-->
	
	<link rel="shortcut icon" type="image/x-icon" href="assets/favicon.ico">
		
	<link rel="stylesheet" type="text/css" href="stylesheets/jquery.jqzoom.css" >
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .sidebar-nav {
        padding: 9px 0;
      }

      @media (max-width: 980px) {
        /* Enable use of floated navbar text */
        .navbar-text.pull-right {
          float: none;
          padding-left: 5px;
          padding-right: 5px;
        }
      }
	  
	  
    .flowBreak
	{
		clear:both
	}
	
	.zoomable img {max-width:none}
    </style>
    
  </head>
  <body>
<h1 id='degraph_manual'>Degraph Manual</h1>
<div class='maruku_toc'><ul style='list-style: none;'><li><a href='#introduction'>Introduction</a></li><li><a href='#visualization_of_dependencies'>Visualization of Dependencies</a><ul style='list-style: none;'><li><a href='#getting_started'>Getting Started</a><ul style='list-style: none;'><li><a href='#the_structure_of_degraph'>The structure of Degraph</a><ul style='list-style: none;'><li><a href='#configuration_file'>Configuration File</a></li><li><a href='#result'>Result</a></li></ul></li><li><a href='#overall_structure_of_log4j'>Overall structure of Log4J</a><ul style='list-style: none;'><li><a href='#configuration_file'>Configuration File</a></li><li><a href='#result'>Result</a></li></ul></li><li><a href='#the_spi_and_helpers_packages_of_log4j'>The spi and helpers packages of Log4J</a><ul style='list-style: none;'><li><a href='#configuration_file'>Configuration File</a></li><li><a href='#result'>Result</a></li></ul></li></ul></li><li><a href='#the_configuration_file_format'>The Configuration File Format</a><ul style='list-style: none;'><li><a href='#example_file'>Example File</a></li><li><a href='#simple_properties'>Simple Properties</a></li><li><a href='#slicing'>Slicing</a></li><li><a href='#the_pattern_matching_syntax'>The pattern matching syntax</a></li></ul></li><li><a href='#working_with_yed'>Working with yed</a><ul style='list-style: none;'><li><a href='#basic_layout'>Basic Layout</a></li><li><a href='#unfolding_nodes'>Unfolding nodes</a></li><li><a href='#overview'>Overview</a></li><li><a href='#neighborhood_view'>Neighborhood View</a></li><li><a href='#general_tips'>General Tips</a></li></ul></li></ul></li><li><a href='#testing_of_dependencies'>Testing of Dependencies</a><ul style='list-style: none;'><li><a href='#scala_constraints_dsl'>Scala Constraints DSL</a><ul style='list-style: none;'><li><a href='#no_circles'>No Circles</a></li><li><a href='#adding_slicings'>Adding Slicings</a></li><li><a href='#simple_constraints_on_slicings'>Simple Constraints On Slicings</a></li><li><a href='#strict_constraints'>Strict Constraints</a></li><li><a href='#unspecified_order_of_slices'>Unspecified Order of Slices</a></li></ul></li><li><a href='#java_constraints_dsl'>Java Constraints DSL</a></li></ul></li><li><a href='#stuff'>Stuff</a><ul style='list-style: none;'><li><a href='#installation'>Installation</a></li><li><a href='#faq'>FAQ</a><ul style='list-style: none;'><li><a href='#the_resulting_graph_is_empty'>The resulting Graph is empty</a></li><li><a href='#analyzing_my_classes_takes_for_ever__yed_takes_for_ever_to_load_or_display_my_graphml_file'>Analyzing my classes takes for ever / yed takes for ever to load or display my graphml file</a></li></ul></li><li><a href='#a_little_theory'>A little Theory</a></li><li><a href='#nomenclature'>Nomenclature</a><ul style='list-style: none;'><li><a href='#node'>Node</a></li><li><a href='#simple_node'>Simple Node</a></li><li><a href='#complex_node'>Complex Node</a></li><li><a href='#slice'>Slice</a></li><li><a href='#slice_type'>Slice Type</a></li><li><a href='#slicing'>Slicing</a></li><li><a href='#slice_node'>Slice Node</a></li></ul></li></ul></li><li><a href='#ressources'>Ressources</a><ul style='list-style: none;'><li><a href='#feedback'>Feedback</a></li><li><a href='#sources'>Sources</a></li><li><a href='#keep_up_to_date'>Keep Up To Date</a></li></ul></li></ul></div>
<h2 id='introduction'>Introduction</h2>

<p>Degraph is a tool for visualizing and controlling class and package dependencies in JVM applications.</p>

<p>There are two basic usages: You can <strong>analyze classes and create a graphml file</strong> which then can be rendered and interpreted using <a href='http://yed.yworks.com'>yed, a free graph editor</a>.</p>

<p>Or you can <strong>define constraints on the dependency</strong> using an internal Scala DSL <strong>and run tests</strong> to prevent violations of your desired dependency structure.</p>

<p>What makes Degraph different from other similar tools is that it supports nested graphs. Inner classes are visualy contained in their containing class; Classes are contained inside packages and if you want you can group packages to modules, layers and so on. These ways of grouping classes are <span>referred to as slicings in Degraph(#nomenclature).</span></p>

<p>If you do a hierarchic layout in yed for the resulting graphml file you can easily see which classes you can move to different packages, layer or modules without creating circular dependencies or which you have to move in order to break cycles.</p>

<h2 id='visualization_of_dependencies'>Visualization of Dependencies</h2>

<p>Visualization of Dependencies can be very helpfull when you try to understand the structure (or the absence of such structure) of dependencies in a project. Lets get started right away by analyzing Degraph and some of it&#8217;s components itself.</p>

<h3 id='getting_started'>Getting Started</h3>

<p>The following images are created (and can be recreated by yourself) by</p>

<ul>
<li>downloading degraph</li>

<li>unzip to a directory ( <em>theDir</em> )</li>

<li>open a console and change into <em>theDir</em>/degraph/bin</li>

<li>execute <code>degraph -f ../example/example#.config</code> with # replace by one of the digits 1, 2 or 3</li>

<li>open the resulting <code>example#.graphml&#39; in yed, opening up some of the nodes and applying an hierarchic layout. </code></li>
</ul>

<p>Move your mouse over the images to see enlarged versions of the images</p>

<h4 id='the_structure_of_degraph'>The structure of Degraph</h4>

<h5 id='configuration_file'>Configuration File</h5>

<p>The configuration file example1.config might look like this (details may vary with the version of Degraph)</p>

<pre><code>output = example1.graphml
classpath = ../lib/degraph-0.0.3.jar
exclude = java*.**
exclude = scala.**
exclude = org.scalatest.**
part = {
    de.schauderhaft.*.(*).**
}
lib = {
	de.schauderhaft.(*).**
	*.(*).**
}
internalExternal = {
   internal de.schauderhaft.**
   external **
}</code></pre>

<p>Note that there are two simple excludes for filtering out scala and java core libraries, but other libraries show up in the diagram, although they are not part of the analyzed jar, but referenced from the jar.</p>

<p>Everything after the excludes is the configuration of slicings. See the <a href='#the_configuration_file_format'>documentation of the configuration file format for details</a>.</p>

<h5 id='result'>Result</h5>
<a href='images/selfTest.png' class='zoomable'>  
    <img src='images/selfTest_small.png' />  
</a><div class='flowBreak'>
</div>
<p>Degraph is rather boring to look at since it is rather small and also has a very clean package structure (after all it is a tool for managing package structure). So lets look at a more interesting example.</p>

<h4 id='overall_structure_of_log4j'>Overall structure of Log4J</h4>

<p>Let&#8217;s have a look at Log4J. Note that although we&#8217;ll find stuff that I&#8217;d consider not clean, Log4J library is one of the most important little gems in the Java universe, and no matter how it looks in the inside, it does its job rather well, and that is the most important thing.</p>

<h5 id='configuration_file'>Configuration File</h5>

<p>The configuration file looks like this.</p>

<pre><code>output = example2.graphml
classpath = ../lib/log4j-1.2.16.jar
include = org.apache.log4j.**
part = {
    org.apache.log4j.(*).**
}

It specifies the jar to analyze and only includes stuff from `log4j` itself. So we won&#39;t see any `java.lang` stuff it might depend on. Also the configuration consideres the first package part after `org.apache.log4j` as a *part*. This means it will create nodes on that level, containing all the classes in the respective packages and subpackages.</code></pre>

<h5 id='result'>Result</h5>
<a href='images/example2.png' class='zoomable'>  
    <img src='images/example2_small.png' />  
</a><div class='flowBreak'>
</div>
<p>As you can see the diagram is rather large. If the dependency structure would be cycle free, there would be only arrows going from left to right. But there are many arrows going from right to left, so we have circles. Actually in a current version of Degraph cycles would be colored red and this diagram would be rather colorfull.</p>

<p>Two parts seem to be very important: <code>helpers</code> and <code>spi</code> there are lots of arrows to and from those nodes. I&#8217;d be rather skeptical about a <code>helpers</code> package in itself, especially when it has so many dependencies, but look at the two package and their subpackages, by filtering out everything else.</p>

<h4 id='the_spi_and_helpers_packages_of_log4j'>The spi and helpers packages of Log4J</h4>

<h5 id='configuration_file'>Configuration File</h5>

<p>This is basically the same configuration as before, just with the includes fine tuned to only include the <code>spi</code> and the <code>helper</code> package.</p>

<pre><code>output = example3.graphml
classpath = ../lib/log4j-1.2.16.jar
include = org.apache.log4j.spi.**
include = org.apache.log4j.helpers.**
part = {
    org.apache.log4j.(*).**
}</code></pre>

<h5 id='result'>Result</h5>
<a href='images/example3.png' class='zoomable'>  
    <img src='images/example3_small.png' />  
</a><div class='flowBreak'>
</div>
<p>For this diagram I expanded all the nodes, to see the details of the cycle between the two packages. What are we looking at? The two outer light green boxes are the parts specified through the configuration file: <code>spi</code> and <code>helpers</code>. Contained in those parts is only a single package <code>org.apache.log4j.spi</code> and <code>org.apache.log4j.helpers</code>. Although there is a one to one relationship this doesn&#8217;t have to be this way with other configurations. The packages nodes visually contain all the classes. There is one special case: the <code>PatternParser</code> class has inner classes so it becomes itself a group node containing the nodes for the inner classes.</p>

<p>As one might have guessed the helpers package contains all kinds of stuff. If we look at the dependencies between <code>spi</code> and <code>helpers</code> we note that all dependencies go from left to right, which is a good sign, because it makes it likely that it is rather easy to break this cycle. Note that we still have a cycle because the arrows are going up and down between the nodes. This is what I call the <a href='http://blog.schauderhaft.de/2013/03/24/dependency-antipatterns-the-bypass/'>Bypass Antipattern of Package Dependencies</a>.</p>

<p>If we extract the classes for <code>helpers</code> that <code>spi</code> depends on into a seperate package we should be able to improve the situation. That would be the classes <code>LogLog</code> and <code>Loader</code>. But we have to take <code>OptionConverter</code> along for the ride, since it is entangled with the other two. Now we can immediatly see that <code>OptionConverter</code> depends on <code>Configurator</code> which is again in the <code>spi</code> part, which would cause another cycle, so take it into the new package as well, and the result should have one cycle less.</p>

<p><strong>This is the power of Degraph: that you can see all the dependencies of all classes in the packages you decided to look at. This enables you to easily identify classes that you can or should move.</strong></p>

<h3 id='the_configuration_file_format'>The Configuration File Format</h3>

<p>Except for very basic experiments you&#8217;ll want to specify a configuration file using the <strong>-f</strong> command line argument. This section describes the format of the configuration file.</p>

<h4 id='example_file'>Example File</h4>

<p>We&#8217;ll go through the different parts of the configuration file by examining an example, which is also included in the distribution of Degraph</p>

<pre><code>output = example1.graphml
classpath = ../lib/degraph-0.0.3.jar
exclude = java*.**
exclude = scala.**
exclude = org.scalatest.**
part = {
    de.schauderhaft.*.(*).**
}
lib = {
	de.schauderhaft.(*).**
	*.(*).**
}
internalExternal = {
   internal de.schauderhaft.**
   external **
}</code></pre>

<h4 id='simple_properties'>Simple Properties</h4>

<p>You can provide simple properties for the path to analyze, the name of the file to generate, classes to include or exclude using the syntax</p>

<pre><code>&lt;property&gt;=&lt;value&gt;</code></pre>

<p>Available properties are:</p>

<ul>
<li>output - the file where the resulting graphml file will be created. Relative paths are relative to your current directory when you start degraph.</li>

<li>classpath - this is the path to analyze. It is a list of files and directories seperated by the classpath separation character of your platform, i.e. <code>&#39;:&#39;</code> on Unix and <code>&#39;;&#39;</code> ond windows. All class and jar files found in those directories or subdirectories will get picked up by Degraph.</li>

<li>exclude an Ant like pattern of class names to exclude from the analysis</li>

<li>include an Ant like pattern of class names to include from the analysis. If not specified, all classes (minus any excludes) are inlcuded. There can be an arbitrary number of exclude and includes specified and the order does not matter.</li>
</ul>

<p>Each property has to stand on its own line.</p>

<h4 id='slicing'>Slicing</h4>

<p>You can specify an arbitrary number of slicings through your code base. A slicing is a grouping of classes that in some sense belong to each other. Examples might be:</p>

<ul>
<li>classes belonging to the same library, like <em>hibernate</em>, <em>log4j</em> and so on.</li>

<li>classes belonging to the same module, like <em>shoppingcart</em>, <em>authentication</em>, <em>fullfillment</em>.</li>

<li>classes belonging to the same layer, like <em>UI</em>, <em>domain</em>, <em>persistence</em>, <em>restapi</em></li>

<li>classes belonging to your code vs. external stuff: <em>internal</em>, <em>external</em></li>
</ul>

<p>For each slicing you want to apply you add a section like this to the configuration:</p>

<pre><code>&lt;slicinglabel&gt; = {
    &lt;list of patterns&gt;
}</code></pre>

<p>Note that the opening <code>{</code> has to be on the same line as the label and <code>=</code> sign while the closing <code>}</code> has to be on its own line. Patterns come in two and a half flavors:</p>

<p><em>Named patterns</em> look like this:</p>

<pre><code>&lt;name&gt; &lt;pattern&gt;</code></pre>

<p>Every class that is matched by the pattern is part of the slice given by the name. So a pattern of</p>

<pre><code>mine de.schauderhaft.** </code></pre>

<p>will put all classes with a full qualified name starting with <code>de.schauderhaft.</code> in a slice named <code>mine</code>.</p>

<p><em>Simple patterns</em> look like this:</p>

<pre><code>&lt;pattern&gt;</code></pre>

<p>or</p>

<pre><code>&lt;prefix&gt;(&lt;naming part&gt;)&lt;suffix&gt;</code></pre>

<p>A class matched by this pattern will get added to the slice given by the full <code>&lt;pattern&gt;</code> (first case) or by the <code>&lt;naming part&gt;</code> in the second case.</p>

<p>For example this pattern</p>

<pre><code>*.(*).** </code></pre>

<p>will put all classes from <code>org.junit.</code> in the slice <code>junit</code> and all the stuff from <code>org.hibernate.</code> in the slice <code>hibernate</code>.</p>

<p>All patterns in a slicing definition (i.e. between <code>{</code>and <code>}</code>) will get tried in order for each class until a match is found. That match defines the slice used for the class.</p>

<h4 id='the_pattern_matching_syntax'>The pattern matching syntax</h4>

<p>Pattern matching in the definition of slices uses an Ant like syntax for specifying full qualified class names. With <code>*</code> standing in for an arbitrary number (0-n) of arbitrary characters, but no dots. <code>**</code> matches and arbitrary number (0-n) of arbitrary characters, including dots.</p>

<h3 id='working_with_yed'>Working with yed</h3>

<p>Degraph generates <code>.graphml</code> files that are intended to be rendered using <a href='http://yed.yworks.com'>yed</a>. Yed is a general purpose graph editor with strong layout capabilities. Lots of its capabilities aren&#8217;t needed when working with files from Degraph. So this article describes an efficient way to work with it.</p>

<p>I&#8217;ll assume you have downloaded and installed yed. So go ahead and start it up.</p>

<p>I also assume you have a graphml file ready. If not, head over to the <a href='#visualization_of_dependencies'>getting started section</a> and learn how to create one.</p>

<h4 id='basic_layout'>Basic Layout</h4>

<p>On startup you get various options what to do. Choose &#8216;Open&#8230;&#8217; and select the graphml file you want to view.</p>

<p>You will probably see a single box. That&#8217;s ok, don&#8217;t worry. Degraph doesn&#8217;t generate any layout information on its own, so all boxes are located at the same position, hiding behind each other. We&#8217;ll change that in a second.</p>

<p>Select the menu Layout -&gt; Hierarchical &#8230;</p>

<p>This opens a dialog. Select the following options and leave everything else as it is.</p>

<p>On the General tab</p>

<p>Orientation: Left to Right</p>

<p>On the Edges tab</p>

<p>Routing Style: Polyline</p>

<p>Click on the Dock button. This will put the dialog in the side bar.</p>

<p>Press the green triangle play button.</p>

<p>Voila, you should now see your graph nicely laid out.</p>

<h4 id='unfolding_nodes'>Unfolding nodes</h4>

<p>You are now seeing nodes representing slices (either custom slices configured in the configuration file or packages). You can unfold those slices by clicking on the little + marker in the top left corner. After that you probably want to layout the graph again. That&#8217;s why we docked the layout dialog. You just have to press the play button once more.</p>

<h4 id='overview'>Overview</h4>

<p>In the Overview (it&#8217;s open by default) you can see a tiny version of the complete graph. If you zoom in, in the main window (for example using the scrollwheel) the overview will highlight the area you are looking at in the main view. You can drag that view port around using the mouse in the Overview, allowing you to quickly navigate even a large graph.</p>

<h4 id='neighborhood_view'>Neighborhood View</h4>

<p>Yed offers a couple of context views. For our purpose the must useful one is the Neighborhood View. It might be already docked on the side of the screen. If not, open it up using the menu Windows -&gt; Context Views -&gt; Neighborhood View. You might want to increase it in size.</p>

<p>If you now click on a node or an edge it shows you the predecessor and successor nodes of whatever you selected. Very helpful if you try to prune dependencies from a class.</p>

<h4 id='general_tips'>General Tips</h4>

<p>No matter how sophisticated a layout algorithm is. A graph with 1000s of nodes and even more edges will look messy. In order to limit the size of graph you have to deal with use the following techniques:</p>

<ul>
<li>
<p>Collapse nodes which you don&#8217;t care about in detail</p>
</li>

<li>
<p>Remove collapsed nodes which you don&#8217;t care about at all, this will also delete all contained nodes.</p>
</li>

<li>
<p>When changing your code based on what you see in the graph, you&#8217;ll probably want to look at the same nodes over and over again. Use filters in your configuration file to limit the nodes generated.</p>
</li>
</ul>

<h2 id='testing_of_dependencies'>Testing of Dependencies</h2>

<p>When you decided what kind of dependencies you want to have in your project, and which you don&#8217;t, you probably want to ensure that everybody involved sticks to these rules. Degraph will help you with that.</p>

<p>The basic idea is to have a simple set of rules based on the slices you have anyway.</p>

<h3 id='scala_constraints_dsl'>Scala Constraints DSL</h3>

<p>The scala constraints DSL of Degraph is based on <a href='http://www.scalatest.org/'>ScalaTest</a> <a href='http://www.scalatest.org/user_guide/using_matchers'>matchers</a>.</p>

<h4 id='no_circles'>No Circles</h4>

<p>A good start is to check if your application contains dependency cycles. A complete test might look like this:</p>

<pre><code>import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner
import org.scalatest.matchers.ShouldMatchers
import org.scalatest.FunSuite
import de.schauderhaft.degraph.check.Check._
    
@RunWith(classOf[JUnitRunner])
class DependencyTest extends FunSuite with ShouldMatchers {

    test(&quot;Degraph has no cycles&quot;) {
        classpath.including(&quot;de.schauderhaft.**&quot;) should be(violationFree)
    }
}</code></pre>

<p>The <code>RunWith</code> annotation is only needed so this ScalaTest test becomes a JUnit test. I like it that way, because it allows me to use the JUnit plugin of my IDE to execute the tests, but it is not essential.</p>

<p>Most of the rest is just a standard ScalaTest test. There are really just two interesting lines:</p>

<pre><code>import de.schauderhaft.degraph.check.Check._</code></pre>

<p>and</p>

<pre><code>classpath.including(&quot;de.schauderhaft.**&quot;) should be(violationFree)</code></pre>

<p>The import makes the Degraph DSL available. The second one is the actual test.</p>

<p><code>classpath</code> is a predefined <code>Configuration</code> containing the current classpath as the path to get analyzed. A <code>Configuration</code> is the class used to configure Degraph. When you use a configuration file to configure Degraph you are basically creating a <code>Configuration</code> instance.</p>

<p><code>including</code> is a method which allows to define an include filter. Without specifying a filter, Degraph would analyze everything in your classpath. Since this most probably also includes all kinds of libraries, it is a really good idea to limit the result to your own stuff, as I did here.</p>

<p><code>violationFree</code> is the actual matcher that checks all defined dependency constraints. But did we define any? Yes we did. By default every <code>Configuration</code> contains the constraint that no cycles are allowed. To be more precise: Every slice type gets checked if it results in any cycles. If so these cycles will be considere a dependency violation.</p>

<h4 id='adding_slicings'>Adding Slicings</h4>

<p><em>To be defined</em> (Right now there is only the default slicing &#8217;<code>package</code>&#8217; defined.</p>

<h4 id='simple_constraints_on_slicings'>Simple Constraints On Slicings</h4>

<p>Thes following specifies that with the slicing &#8216;part&#8217; the slice &#8216;check&#8217; may depend on any of &#8216;configuration&#8217;, &#8216;graph&#8217; or &#8216;model&#8217;. The slice &#8216;configuration&#8217; may depend on any of &#8216;graph&#8217; and &#8216;model&#8217; but not on &#8216;check&#8217; and so on. Or to put it differently: Dependencies from left to right are ok, from right to left aren&#8217;t. This kind of constraint is usefull for slicings specifying business modules, where you want to enforce some ordering.</p>

<pre><code>classpath.forType(&quot;part&quot;).allow(&quot;check&quot;, &quot;configuration&quot;, &quot;graph&quot;, &quot;model&quot;)</code></pre>

<p><code>forType</code> specifies the slice type this constraint applies to. Note that there is a predefined slicing named &#8216;package&#8217;</p>

<p><code>allow</code> allows dependencies between the given slices from left to right, but not from right to left.</p>

<p>Dependencies from and to classes not part of the specified slices ar not constraint.</p>

<h4 id='strict_constraints'>Strict Constraints</h4>

<p>If you don&#8217;t want to allow dependencies to skip layers, you use <code>allowDirect</code> instead of <code>allow</code>. So the following allows &#8216;check&#8217; to depend on &#8216;configuration, but it disallows a dependency from &#8216;check&#8217; to &#8216;graph&#8217; or &#8216;model&#8217; since that would skip &#8216;configuration&#8217;</p>

<pre><code>classpath.forType(&quot;part&quot;).allowDirect(&quot;check&quot;, &quot;configuration&quot;, &quot;graph&quot;, &quot;model&quot;)</code></pre>

<p>Classes not part of the specified slices may depend on the first element in the list, and the last element in the list may depend on such unspecified classes.</p>

<h4 id='unspecified_order_of_slices'>Unspecified Order of Slices</h4>

<p>If there is a group of slices for which you don&#8217;t care about the order, you can specify them using <code>anyOf</code> like in the following example:</p>

<pre><code>classpath.forType(&quot;part&quot;).allow(&quot;check&quot;, anyOf( &quot;configuration&quot;, &quot;graph&quot;), &quot;model&quot;)</code></pre>

<p>The meaning of this constraint is very similar to <a href='#simple_constraint_above'>the simple constraint above</a>, with the exception that dependencies from &#8216;configuration&#8217; to &#8216;graph&#8217; are allowed just as the other way round. Of course the &#8216;no cycles&#8217; constraint still applies so both directions of dependencies must not be present at the same time.</p>

<h3 id='java_constraints_dsl'>Java Constraints DSL</h3>

<p>Once the Scala DSL is somewhat finished there will also be a Java version. But since creating a DSL in Scala is so much easier and nicer, Scala comes first. Of course you might consider picking up a little Scala just for a small set of dependency tests &#8230;</p>

<h2 id='stuff'>Stuff</h2>

<h3 id='installation'>Installation</h3>

<p>For using Degraph you need a JDK 7 or higher properly installed. It might work with older versions but we never tried &#8230; let us know if you try it.</p>

<p>Take the downloaded zip file and unzip it to a place you like.</p>

<p>Done. You can now start Degraph by executing the degraph in the bin folder. If you want to you can add degraph to your path to make executing it a little easier.</p>

<h3 id='faq'>FAQ</h3>

<h4 id='the_resulting_graph_is_empty'>The resulting Graph is empty</h4>

<p>Make sure you specify the correct path to the <strong>class</strong>-files. Source files don&#8217;t work. Paths that don&#8217;t contain class-files (nor jar files, containing class files) will be silently ignored. So a typo in the path specified easily results in a empty graphml file.</p>

<h4 id='analyzing_my_classes_takes_for_ever__yed_takes_for_ever_to_load_or_display_my_graphml_file'>Analyzing my classes takes for ever / yed takes for ever to load or display my graphml file</h4>

<p>Given a path Degraph analyzes everything that looks like a class file in that directory or in subdirectories, including jar files. So if you use the root directory of a large multi module project in standard maven layout, it will analyze all the class files of the project (test and main). If have jars in there, those will get analyzed as well.</p>

<p>Make sure you have only those classes / jars in the path given to Degraph, that you are really interested in. Make use of the filter options to limit the classes that actually end up in the graph.</p>

<h3 id='a_little_theory'>A little Theory</h3>

<h3 id='nomenclature'>Nomenclature</h3>

<p>Degraph abstracts over some things which most of the time don&#8217;t get abstract over. Therefore I had to come up with some names. This of course is somewhat confusing for people until they understand these name, so this page is here to help.</p>

<h4 id='node'>Node</h4>

<p>A node is something displayed as a box by yed. It might represent a class, package or the intersection of slices of different slice type.</p>

<h4 id='simple_node'>Simple Node</h4>

<p>A simple node is a node that doesn&#8217;t have any further substructure. Currently simple nodes represent classes, but one day there might be simple nodes representing a bean in a spring configuration or similar things.</p>

<h4 id='complex_node'>Complex Node</h4>

<p>A Complex Node is one which has content. There are two kinds of complex nodes: Slice Nodes (see below) and nodes representing classes with inner classes.</p>

<h4 id='slice'>Slice</h4>

<p>A slice is a collection of simple nodes. A slice has a slice type. All the classes in the package &#8216;de.schauderhaft.degraph&#8217; might be a slice, with the slice type &#8216;package&#8217;. All the classes in the package or subpackages of &#8216;org.apache&#8217; might be part of the slice &#8216;apache&#8217; of type &#8216;lib&#8217;. What slices exist depends on the slicings defined in the configuration file. Note: slices are not slice nodes these are different things although the difference is maybe a little hard to grasp. See below for details</p>

<h4 id='slice_type'>Slice Type</h4>

<p>A slice type is a categorization of slices. It can be considered the name of a slicing. All slices with the same type are disjunct, i.e. no simple node is in more than one slice of the same slice type.</p>

<h4 id='slicing'>Slicing</h4>

<p>The way how all the simple nodes gets distributed into a set of slices which all have the same slice type. This is what you define in a configuration file with something like</p>

<pre><code>lib {
    org.(*).**
    (*.*).**
}</code></pre>

<p>This says: I define the slicing of type &#8216;lib&#8217; such that everything starting with &#8216;org.&#8217; ends up in the slice given by the second part of the package name. Everything else ends up in the slice given by the first two parts of the package name.</p>

<p>There is one implicit slicing: the one defined by packages.</p>

<h4 id='slice_node'>Slice Node</h4>

<p>a slice node is a node representing a set of slices with mutual distinct type. Ok, take a deep breath. This is going to be a little tricky.</p>

<p>You might think a Slice Node is the same as a Slice, or just the visual representation of a Slice. But there is a little but important difference. Lets imagine a tiny project with two classes:</p>

<p><code>de.schauderhaft.Example</code> and <code>de.schauderhaft.ExampleTest</code></p>

<p>Lets work with two slicings:</p>

<ol>
<li>
<p>The default package slicing, which puts each class in its package.</p>
</li>

<li>
<p>A <em>deployUnit</em> slicing which puts everything containing the String &#8216;Test&#8217; in the slice &#8216;Test&#8217; and everything else in the slice &#8216;Main&#8217;</p>
</li>
</ol>

<p>So we have three slices: <code>deployUnit:Test</code>, <code>deployUnit:Main</code>, <code>package:de.schauderhaft</code></p>

<p>But if you look at it in yed you&#8217;ll see:</p>

<p><code>Test</code>, <code>de.schauderhaft in Test</code>, <code>Main</code> and <code>de.schauderhaft in Main</code> these are <em>Slice Nodes</em>. The important part is that the slice <code>de.schauderhaft</code> got duplicated because it contains classes that according to another slicing belong to two different slices.</p>

<p>Note 1: For slicings other then the package slicing you can control the order by which they get applied by the order in which they appear in the configuration file.</p>

<p>Note 2: Conceptually &#8216;a in b&#8217; is considered the same Slice Node as &#8216;b in a&#8217;</p>

<h2 id='ressources'>Ressources</h2>

<h3 id='feedback'>Feedback</h3>

<p>If you have a problem using Degraph, a question, a bug or an idea: Go ahead and create an issue at <a href='https://github.com/schauder/degraph/issues?state=open'>Degraphs issue tracker</a>.</p>

<h3 id='sources'>Sources</h3>

<p>You can find the source code to <a href='https://github.com/schauder/degraph'>Degraph at github</a>.</p>

<h3 id='keep_up_to_date'>Keep Up To Date</h3>

<p>Want to kept updated about news about Degraph? Consider subscribing to the <a href='http://blog.schauderhaft.de'>blog of the author</a>, or keep an eye on the <a href='http:/schauder.github.com/degraph/'>homepage of Degraph</a>.</p>

<p>Don&#8217;t want to miss the next release? Follow the <a href='http://www.twitter.com/jensschauder'>author on twitter</a>.</p>
<!-- scripts --><script src='//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js' type='text/javascript'>
</script><script src='javascripts/jquery.jqzoom-core-pack.js' type='text/javascript'>
</script><script type='text/javascript'>
$(document).ready(function(){  
    $('.zoomable').jqzoom();  
}); 
</script>
  </body
</html>